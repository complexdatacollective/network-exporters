{"version":3,"file":"network-exporters.min.js","sources":["../../src/FileExportManager.js","../../src/consts/reservedAttributes.js"],"sourcesContent":["/* eslint-disable global-require */\nconst { merge, isEmpty, groupBy } = require('lodash');\nconst sanitizeFilename = require('sanitize-filename');\nconst { EventEmitter } = require('eventemitter3');\nconst queue = require('async/queue');\nconst {\n  protocolProperty,\n} = require('./consts/reservedAttributes');\nconst {\n  removeDirectory,\n  makeTempDir,\n} = require('./utils/filesystem');\nconst exportFile = require('./exportFile');\nconst {\n  insertEgoIntoSessionNetworks,\n  resequenceIds,\n  partitionNetworkByType,\n  unionOfNetworks,\n} = require('./formatters/network');\nconst {\n  verifySessionVariables,\n  getFilePrefix,\n  sleep,\n  handlePlatformSaveDialog,\n  ObservableValue,\n} = require('./utils/general');\nconst archive = require('./utils/archive');\nconst { ExportError, ErrorMessages } = require('./errors/ExportError');\nconst ProgressMessages = require('./ProgressMessages');\nconst UserCancelledExport = require('./errors/UserCancelledExport');\nconst { isElectron } = require('./utils/Environment');\n\nconst defaultCSVOptions = {\n  adjacencyMatrix: false,\n  attributeList: true,\n  edgeList: true,\n  // If CSV is exported, egoAttributeList must be exported\n  // as it contains session info so this option is generally\n  // ignored and only relevant for *only* exporting\n  // egoAttributeList\n  egoAttributeList: true,\n};\n\nconst defaultExportOptions = {\n  exportGraphML: true,\n  exportCSV: defaultCSVOptions,\n  globalOptions: {\n    exportFilename: 'networkCanvasExport',\n    unifyNetworks: false,\n    useDirectedEdges: false, // TODO\n    useScreenLayoutCoordinates: true,\n    screenLayoutHeight: 1080,\n    screenLayoutWidth: 1920,\n  },\n};\n\n// Merge default and user-supplied options\nconst getOptions = (exportOptions) => ({\n  ...merge(defaultExportOptions, exportOptions),\n  ...(exportOptions.exportCSV === true ? { exportCSV: defaultCSVOptions } : {}),\n});\n\n/**\n * Interface for all data exports\n */\nclass FileExportManager {\n  constructor(exportOptions = {}) {\n    this.exportOptions = getOptions(exportOptions);\n    this.events = new EventEmitter();\n  }\n\n  on = (...args) => {\n    this.events.on(...args);\n  }\n\n  emit(event, payload) {\n    if (!event) {\n      // eslint-disable-next-line no-console\n      console.warn('Malformed emit.');\n      return;\n    }\n\n    this.events.emit(event, payload);\n  }\n\n  removeAllListeners = () => {\n    this.events.removeAllListeners();\n  }\n\n  /**\n   * Main export method. Returns a promise that resolves an to an object\n   * containing an object with run() and abort() methods that control the task.\n   *\n   * Rejections from this method are fatal errors, but errors within\n   * the run() task only fail that specific task.\n   *\n   * @param {*} sessions    collection of session objects\n   * @param {*} protocols   object keyed by protocolUID (SHA of protocol.name), where each\n   *                        protocols[protocolUID] is a complete protocol object,\n   *                        including codebook. Must contain a key for every session\n   *                        protocol in the sessions collection.\n   */\n  exportSessions(sessions, protocols) {\n    let tmpDir; // will hold temporary directory location\n\n    // This queue instance accepts one or more promises and limits their\n    // concurrency for better usability in consuming apps\n    // https://caolan.github.io/async/v3/docs.html#queue\n\n    // Set concurrency to conservative values for now, based on platform\n    const QUEUE_CONCURRENCY = isElectron() ? 50 : 1;\n\n    const q = queue((task, callback) => {\n      task()\n        .then((result) => callback(null, result))\n        .catch((error) => callback(error));\n    }, QUEUE_CONCURRENCY);\n\n    const exportFormats = [\n      ...(this.exportOptions.exportGraphML ? ['graphml'] : []),\n      ...(this.exportOptions.exportCSV ? ['ego'] : []),\n      ...(this.exportOptions.exportCSV.adjacencyMatrix ? ['adjacencyMatrix'] : []),\n      ...(this.exportOptions.exportCSV.attributeList ? ['attributeList'] : []),\n      ...(this.exportOptions.exportCSV.edgeList ? ['edgeList'] : []),\n    ];\n\n    // Cleanup function called by abort method, after fatal errors, and after\n    // the export promise resolves.\n    const cleanUp = () => {\n      q.kill();\n      if (tmpDir) {\n        try {\n          removeDirectory(tmpDir);\n        } catch (error) {\n          // eslint-disable-next-line no-console\n          console.error('Error removing temp directory:', error);\n        }\n      }\n    };\n\n    this.emit('begin', ProgressMessages.Begin);\n\n    // Reject if required parameters aren't provided\n    if (\n      (!sessions && !isEmpty(sessions))\n      || (!protocols && !isEmpty(protocols))\n    ) {\n      return Promise.reject(new ExportError(ErrorMessages.MissingParameters));\n    }\n\n    // Will resolve with an object containing run() and abort() methods\n    return new Promise((resolveExportPromise) => {\n      // State variables for this export\n      let cancelled = false;\n      const succeeded = [];\n      const failed = [];\n\n      const consideringCancel = new ObservableValue(false);\n\n      const shouldContinue = () => !cancelled;\n\n      // Main work of the process happens here\n      const run = () => new Promise((resolveRun, rejectRun) => {\n        makeTempDir().then((dir) => { tmpDir = dir; })\n          // Short delay to give consumer UI time to render\n          .then(sleep(1000))\n          .then(() => {\n            if (!shouldContinue()) {\n              throw new UserCancelledExport();\n            }\n          })\n          // Insert a reference to the ego ID into all nodes and edges\n          .then(() => {\n            this.emit('update', ProgressMessages.Formatting);\n            // Insert a reference to the ego ID into all nodes and edges\n            return insertEgoIntoSessionNetworks(sessions);\n          })\n          // Resequence IDs for this export\n          .then((sessionsWithEgo) => resequenceIds(sessionsWithEgo))\n          // Group sessions by protocol UUID\n          .then((sessionsWithResequencedIDs) => groupBy(sessionsWithResequencedIDs, `sessionVariables.${protocolProperty}`))\n          // Then, process the union option\n          .then((sessionsByProtocol) => {\n            if (!shouldContinue()) {\n              throw new UserCancelledExport();\n            }\n\n            if (!this.exportOptions.globalOptions.unifyNetworks) {\n              return sessionsByProtocol;\n            }\n\n            this.emit('update', ProgressMessages.Merging);\n            return unionOfNetworks(sessionsByProtocol);\n          })\n          .then((unifiedSessions) => {\n            if (!shouldContinue()) {\n              throw new UserCancelledExport();\n            }\n\n            const promisedExports = [];\n\n            // Create an array of promises representing each session in each export format\n            const finishedSessions = [];\n            const sessionExportTotal = this.exportOptions.globalOptions.unifyNetworks\n              ? Object.keys(unifiedSessions).length : sessions.length;\n\n            Object.keys(unifiedSessions).forEach((protocolUID) => {\n              // Reject if no protocol was provided for this session\n              if (!protocols[protocolUID]) {\n                const error = `No protocol was provided for the session. Looked for protocolUID ${protocolUID}`;\n                this.emit('error', error);\n                failed.push(error);\n                return;\n              }\n\n              unifiedSessions[protocolUID].forEach((session) => {\n                // Skip if sessions don't have required sessionVariables\n                try {\n                  if (this.exportOptions.globalOptions.unifyNetworks) {\n                    Object.values(session.sessionVariables)\n                      .forEach((sessionVariables) => {\n                        verifySessionVariables(sessionVariables);\n                      });\n                  } else {\n                    verifySessionVariables(session.sessionVariables);\n                  }\n                } catch (e) {\n                  failed.push(e);\n                  return;\n                }\n\n                const protocol = protocols[protocolUID];\n                const prefix = getFilePrefix(\n                  session,\n                  protocol,\n                  this.exportOptions.globalOptions.unifyNetworks,\n                );\n\n                // Returns promise resolving to filePath for each format exported\n                exportFormats.forEach((format) => {\n                  // Partitioning the network based on node and edge type so we can create\n                  // an individual export file for each type\n                  const partitionedNetworks = partitionNetworkByType(\n                    protocol.codebook,\n                    session,\n                    format,\n                  );\n\n                  partitionedNetworks.forEach((partitionedNetwork) => {\n                    const partitionedEntity = partitionedNetwork.partitionEntity;\n                    promisedExports.push(() => new Promise((resolve, reject) => {\n                      try {\n                        exportFile(\n                          prefix,\n                          partitionedEntity,\n                          format,\n                          tmpDir,\n                          partitionedNetwork,\n                          protocol.codebook,\n                          this.exportOptions,\n                        ).then((result) => {\n                          if (!finishedSessions.includes(prefix)) {\n                            // If we unified the networks, we need to iterate sessionVariables and\n                            // emit a 'session-exported' event for each sessionID\n                            if (this.exportOptions.globalOptions.unifyNetworks) {\n                              Object.values(session.sessionVariables)\n                                .forEach((sessionVariables) => {\n                                  this.emit('session-exported', sessionVariables.sessionId);\n                                });\n                            } else {\n                              this.emit('session-exported', session.sessionVariables.sessionId);\n                            }\n\n                            this.emit('update', ProgressMessages.ExportSession(finishedSessions.length + 1, sessionExportTotal));\n                            finishedSessions.push(prefix);\n                          }\n                          resolve(result);\n                        }).catch((e) => reject(e));\n                      } catch (error) {\n                        this.emit('error', `Encoding ${prefix} failed: ${error.message}`);\n                        this.emit('update', ProgressMessages.ExportSession(finishedSessions.length + 1, sessionExportTotal));\n                        reject(error);\n                      }\n                    }));\n                  });\n                });\n              });\n            });\n\n            q.push(promisedExports, (err, result) => {\n              if (err) {\n                failed.push(err);\n                return;\n              }\n              succeeded.push(result);\n            });\n\n            return new Promise((resolve, reject) => q.drain()\n              .then(() => resolve({ exportedPaths: succeeded, failedExports: failed }))\n              .catch(reject));\n          })\n          // Then, Zip the result.\n          .then(({ exportedPaths, failedExports }) => {\n            if (!shouldContinue()) {\n              throw new UserCancelledExport();\n            }\n\n            // FatalError if there are no sessions to encode and no errors\n            if (exportedPaths.length === 0 && failedExports.length === 0) {\n              throw new ExportError(ErrorMessages.NothingToExport);\n            }\n\n            // If we have no files to encode (but we do have errors), finish\n            // the task here so the user can see the errors\n            if (exportedPaths.length === 0) {\n              this.emit('finished', ProgressMessages.Finished);\n              cleanUp();\n              resolveRun();\n              cancelled = true;\n              return Promise.resolve();\n            }\n\n            const emitZipProgress = (percent) => this.emit('update', ProgressMessages.ZipProgress(percent));\n\n            // Start the zip process, and attach a callback to the update\n            // progress event.\n            this.emit('update', ProgressMessages.ZipStart);\n            return archive(\n              exportedPaths,\n              tmpDir,\n              sanitizeFilename(this.exportOptions.globalOptions.exportFilename),\n              emitZipProgress,\n              shouldContinue,\n            );\n          })\n          .then((zipLocation) => {\n            if (!shouldContinue()) {\n              throw new UserCancelledExport();\n            }\n\n            this.emit('update', ProgressMessages.Saving);\n            return zipLocation;\n          })\n          .then((zipLocation) => {\n            if (!shouldContinue()) {\n              throw new UserCancelledExport();\n            }\n\n            // If the user is considering aborting, don't show the save dialog\n            const waitWhileConsideringAbort = () => new Promise((resolve, reject) => {\n              const resolveWhenReady = (value) => {\n                if (!shouldContinue()) { reject(); }\n                if (value === false) { resolve(); }\n              };\n\n              // Attach a value change listener to our ObservableProperty\n              consideringCancel.registerListener(resolveWhenReady);\n\n              // Call test once on first run\n              resolveWhenReady(consideringCancel.value);\n            });\n\n            return waitWhileConsideringAbort().then(() => handlePlatformSaveDialog(\n              zipLocation,\n              sanitizeFilename(this.exportOptions.globalOptions.exportFilename),\n            ));\n          })\n          .then((saveCancelled) => {\n            if (!shouldContinue()) {\n              throw new UserCancelledExport();\n            }\n\n            if (!saveCancelled) {\n              this.emit('finished', ProgressMessages.Finished);\n            }\n\n            cleanUp();\n            resolveRun();\n          })\n          .catch((err) => {\n            cleanUp();\n            // We don't reject if this is an error from user cancelling\n            if (!(err instanceof UserCancelledExport)) {\n              this.emit('cancelled', ProgressMessages.Cancelled);\n              rejectRun(err);\n            }\n          });\n      }); // End run()\n\n      const abort = () => {\n        // eslint-disable-next-line no-console\n        console.info('Aborting file export.');\n        if (!shouldContinue()) {\n          // eslint-disable-next-line no-console\n          console.warn('This export already aborted. Cancelling abort!');\n          return;\n        }\n        cancelled = true;\n      };\n\n      const setConsideringAbort = (value) => {\n        consideringCancel.value = value;\n      };\n\n      resolveExportPromise({ run, abort, setConsideringAbort });\n    });\n  }\n}\n\nmodule.exports = FileExportManager;\n","// Model properties\nconst entityPrimaryKeyProperty = '_uid';\nconst entityAttributesProperty = 'attributes';\nconst edgeSourceProperty = 'from';\nconst edgeTargetProperty = 'to';\n\n// Session variable properties\nconst caseProperty = 'caseId';\nconst sessionProperty = 'sessionId';\nconst protocolProperty = 'protocolUID';\nconst protocolName = 'protocolName';\nconst sessionStartTimeProperty = 'sessionStart';\nconst sessionFinishTimeProperty = 'sessionFinish';\nconst sessionExportTimeProperty = 'sessionExported';\nconst codebookHashProperty = 'codebookHash';\n\n// Export properties\nconst nodeExportIDProperty = 'nodeID'; // Incrementing ID number for nodes\nconst edgeExportIDProperty = 'edgeID'; // Incrementing ID number for edges\nconst egoProperty = 'networkCanvasEgoUUID';\nconst ncTypeProperty = 'networkCanvasType';\nconst ncProtocolNameProperty = 'networkCanvasProtocolName';\nconst ncCaseProperty = 'networkCanvasCaseID';\nconst ncSessionProperty = 'networkCanvasSessionID';\nconst ncUUIDProperty = 'networkCanvasUUID';\nconst ncSourceUUID = 'networkCanvasSourceUUID';\nconst ncTargetUUID = 'networkCanvasTargetUUID';\n\nmodule.exports = {\n  caseProperty,\n  edgeSourceProperty,\n  edgeTargetProperty,\n  egoProperty,\n  entityAttributesProperty,\n  entityPrimaryKeyProperty,\n  nodeExportIDProperty,\n  edgeExportIDProperty,\n  ncCaseProperty,\n  ncProtocolNameProperty,\n  ncSessionProperty,\n  ncSourceUUID,\n  ncTargetUUID,\n  ncTypeProperty,\n  ncUUIDProperty,\n  protocolName,\n  protocolProperty,\n  sessionExportTimeProperty,\n  sessionFinishTimeProperty,\n  sessionProperty,\n  sessionStartTimeProperty,\n  codebookHashProperty,\n};\n"],"names":["merge","isEmpty","groupBy","require","sanitizeFilename","EventEmitter","queue","protocolProperty","removeDirectory","makeTempDir","exportFile","insertEgoIntoSessionNetworks","resequenceIds","partitionNetworkByType","unionOfNetworks","verifySessionVariables","getFilePrefix","sleep","handlePlatformSaveDialog","ObservableValue","archive","ExportError","ErrorMessages","ProgressMessages","UserCancelledExport","isElectron","defaultCSVOptions","adjacencyMatrix","attributeList","edgeList","egoAttributeList","defaultExportOptions","exportGraphML","exportCSV","globalOptions","exportFilename","unifyNetworks","useDirectedEdges","useScreenLayoutCoordinates","screenLayoutHeight","screenLayoutWidth","module","exports","constructor","_this","this","exportOptions","_defineProperty","events","on","arguments","removeAllListeners","getOptions","emit","event","payload","console","warn","exportSessions","sessions","protocols","tmpDir","QUEUE_CONCURRENCY","q","task","callback","then","result","catch","error","exportFormats","cleanUp","kill","Begin","Promise","reject","MissingParameters","resolveExportPromise","cancelled","succeeded","failed","consideringCancel","shouldContinue","run","resolveRun","rejectRun","dir","Formatting","sessionsWithEgo","sessionsWithResequencedIDs","concat","sessionsByProtocol","Merging","unifiedSessions","promisedExports","finishedSessions","sessionExportTotal","Object","keys","length","forEach","protocolUID","push","session","values","sessionVariables","e","protocol","prefix","format","codebook","partitionedNetwork","partitionedEntity","partitionEntity","resolve","includes","sessionId","ExportSession","message","err","drain","exportedPaths","failedExports","_ref","NothingToExport","Finished","ZipStart","percent","ZipProgress","zipLocation","Saving","resolveWhenReady","value","registerListener","saveCancelled","Cancelled","abort","info","setConsideringAbort","caseProperty","edgeSourceProperty","edgeTargetProperty","egoProperty","entityAttributesProperty","entityPrimaryKeyProperty","nodeExportIDProperty","edgeExportIDProperty","ncCaseProperty","ncProtocolNameProperty","ncSessionProperty","ncSourceUUID","ncTargetUUID","ncTypeProperty","ncUUIDProperty","protocolName","sessionExportTimeProperty","sessionFinishTimeProperty","sessionProperty","sessionStartTimeProperty","codebookHashProperty"],"mappings":"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"}